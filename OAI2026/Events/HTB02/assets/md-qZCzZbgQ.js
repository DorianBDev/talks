import{_ as p}from"./slidev/VClick-Cx1Skfsl.js";import{_ as f}from"./Box.vue_vue_type_script_setup_true_lang-r_ufSKTc.js";import{b as c,o as _,w as i,g as s,e as n,ad as t,i as o,v as g,x as d,T as r}from"./modules/vue-nc2o2shR.js";import{_ as b}from"./two-cols.vue_vue_type_script_setup_true_lang-Bt7yghFQ.js";import{u as y,f as x}from"./slidev/context-Cdg-e9oB.js";import"./index-B3TdmGvl.js";import"./modules/shiki-B7uncE0E.js";const h="/talks/OAI2026/Events/HTB02/assets/cfg_orig-DIWoWknR.png",v="/talks/OAI2026/Events/HTB02/assets/cfg_obf-B8WQ9wym.png",k={class:"ml-2"},N={__name:"slides.md__slidev_27",setup(B){const{$clicksContext:u,$frontmatter:m}=y();return u.setup(),(w,e)=>{const a=f,l=p;return _(),c(b,g(d(r(x)(r(m),26))),{right:i(C=>[s("div",k,[n(l,{at:"5"},{default:i(()=>[n(a,{title:"Automation Possiblities:"},{default:i(()=>e[3]||(e[3]=[s("ul",null,[s("li",null,[t("Meta-heuristic (e.g., Genetic Algorithm): "),s("span",{class:"buble-grey"},"1"),t(),s("span",{class:"buble-grey"},"2"),t(),s("span",{class:"buble-grey"},"3")]),s("li",null,[t("Reinforcement Learning: "),s("span",{class:"buble-grey"},"1"),t(),s("span",{class:"buble-grey"},"2"),t(),s("span",{class:"buble-grey"},"3")]),s("li",null,[t("Heuristic: "),s("span",{class:"buble-grey"},"2"),t(),s("span",{class:"buble-grey"},"3")])],-1)])),_:1,__:[3]})]),_:1})]),n(l,{at:"3"},{default:i(()=>e[4]||(e[4]=[s("div",{style:{display:"flex","justify-content":"center",gap:"0"}},[s("div",{style:{transform:"rotate(90deg)",margin:"0"}},[s("img",{src:h,style:{width:"auto",height:"250px",margin:"0"}})]),s("div",{style:{transform:"rotate(90deg)",margin:"0"}},[s("img",{src:v,style:{width:"auto",height:"220px",margin:"0"}})])],-1)])),_:1,__:[4]}),o(" If only focusing on encryption/decryption, this is polymorphism. If focusing on internal changes, this is metamorphism. If this is a compilation task/not updated during execution/copy, this is obfuscation. "),o(" *morphism is included in obfuscation ")]),default:i(()=>[e[5]||(e[5]=s("h2",null,"Offline Evasion / *morphism",-1)),n(l,{at:"1"},{default:i(()=>[n(a,null,{default:i(()=>e[0]||(e[0]=[s("p",null,[s("ins",null,"Objective:"),t(" Complexify part of a binary to make detection and/or reverse engineering "),s("strong",null,"harder"),t(". This maintains same functionalities, but make "),s("strong",null,"analysis more difficult"),t(".")],-1)])),_:1,__:[0]})]),_:1}),n(l,{at:"2"},{default:i(()=>[n(a,{title:"Automation Surface:"},{default:i(()=>e[1]||(e[1]=[s("ul",null,[s("li",null,"Call graph obfuscation")],-1)])),_:1,__:[1]})]),_:1}),n(l,{at:"4"},{default:i(()=>[n(a,{title:"Examples:"},{default:i(()=>e[2]||(e[2]=[s("ul",null,[s("li",null,[s("span",{class:"buble-grey"},"1"),t(" Maximize binary diff")]),s("li",null,[s("span",{class:"buble-grey"},"2"),t(" Maximize number of subroutines")]),s("li",null,[s("span",{class:"buble-grey"},"3"),t(" Maximize number of calls between each subroutines")])],-1)])),_:1,__:[2]})]),_:1})]),_:1,__:[5]},16)}}};export{N as default};
