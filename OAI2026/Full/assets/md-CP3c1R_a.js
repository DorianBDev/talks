import{_ as p}from"./slidev/VClick-D5zeEe8T.js";import{_ as f}from"./Box.vue_vue_type_script_setup_true_lang-ChYQJdRJ.js";import{b as c,o as _,w as i,g as s,e as l,ad as t,i as o,v as g,x as d,T as r}from"./modules/vue-Dg5UiXBU.js";import{_ as b}from"./two-cols.vue_vue_type_script_setup_true_lang-DrtuzbYo.js";import{u as y,f as x}from"./slidev/context-BsTeL33g.js";import"./index-Wihcs2a9.js";import"./modules/shiki-C_3u9Tgf.js";import"./slidev/VClicks-Yi5U-m0U.js";const h="/talks/OAI2026/Full/assets/cfg_orig-DIWoWknR.png",v="/talks/OAI2026/Full/assets/cfg_obf-B8WQ9wym.png",k={class:"ml-2"},V={__name:"slides.md__slidev_43",setup(w){const{$clicksContext:u,$frontmatter:m}=y();return u.setup(),(C,e)=>{const a=f,n=p;return _(),c(b,g(d(r(x)(r(m),42))),{right:i(I=>[s("div",k,[l(n,{at:"5"},{default:i(()=>[l(a,{title:"Automation Possiblities:"},{default:i(()=>e[3]||(e[3]=[s("ul",null,[s("li",null,[t("Meta-heuristic (e.g., Genetic Algorithm): "),s("span",{class:"buble-grey"},"1"),t(),s("span",{class:"buble-grey"},"2"),t(),s("span",{class:"buble-grey"},"3")]),s("li",null,[t("Reinforcement Learning: "),s("span",{class:"buble-grey"},"1"),t(),s("span",{class:"buble-grey"},"2"),t(),s("span",{class:"buble-grey"},"3")]),s("li",null,[t("Heuristic: "),s("span",{class:"buble-grey"},"2"),t(),s("span",{class:"buble-grey"},"3")])],-1)])),_:1,__:[3]})]),_:1})]),l(n,{at:"3"},{default:i(()=>e[4]||(e[4]=[s("div",{style:{display:"flex","justify-content":"center",gap:"0"}},[s("div",{style:{transform:"rotate(90deg)",margin:"0"}},[s("img",{src:h,style:{width:"auto",height:"250px",margin:"0"}})]),s("div",{style:{transform:"rotate(90deg)",margin:"0"}},[s("img",{src:v,style:{width:"auto",height:"220px",margin:"0"}})])],-1)])),_:1,__:[4]}),o(" If only focusing on encryption/decryption, this is polymorphism. If focusing on internal changes, this is metamorphism. If this is a compilation task/not updated during execution/copy, this is obfuscation. "),o(" *morphism is included in obfuscation ")]),default:i(()=>[e[5]||(e[5]=s("h2",null,"Offline Evasion / *morphism",-1)),l(n,{at:"1"},{default:i(()=>[l(a,null,{default:i(()=>e[0]||(e[0]=[s("p",null,[s("ins",null,"Objective:"),t(" Complexify part of a binary to make detection and/or reverse engineering "),s("strong",null,"harder"),t(". This maintains same functionalities, but make "),s("strong",null,"analysis more difficult"),t(".")],-1)])),_:1,__:[0]})]),_:1}),l(n,{at:"2"},{default:i(()=>[l(a,{title:"Automation Surface:"},{default:i(()=>e[1]||(e[1]=[s("ul",null,[s("li",null,"Call graph obfuscation")],-1)])),_:1,__:[1]})]),_:1}),l(n,{at:"4"},{default:i(()=>[l(a,{title:"Examples:"},{default:i(()=>e[2]||(e[2]=[s("ul",null,[s("li",null,[s("span",{class:"buble-grey"},"1"),t(" Maximize binary diff")]),s("li",null,[s("span",{class:"buble-grey"},"2"),t(" Maximize number of subroutines")]),s("li",null,[s("span",{class:"buble-grey"},"3"),t(" Maximize number of calls between each subroutines")])],-1)])),_:1,__:[2]})]),_:1})]),_:1,__:[5]},16)}}};export{V as default};
